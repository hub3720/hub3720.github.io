<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Flight Simulator - Correção Sombra e Direção</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        #ui { position: absolute; top: 20px; left: 20px; color: #FFF; pointer-events: none; text-shadow: 2px 2px 4px #000; z-index: 10; }
        .info { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #joy-wrapper { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid #FFF; touch-action: none; z-index: 20; }
        #joy-stick { position: absolute; width: 50px; height: 50px; background: #FFF; border-radius: 50%; top: 45px; left: 45px; }
        .thr-box { position: absolute; bottom: 30px; left: 200px; display: flex; flex-direction: column; align-items: center; color: #FFF; z-index: 20; }
        input[type=range] { -webkit-appearance: slider-vertical; width: 30px; height: 140px; }
        .controls { position: absolute; bottom: 20px; right: 20px; z-index: 20; }
        button { padding: 12px 20px; cursor: pointer; background: rgba(255,255,255,0.2); color: #FFF; border: 2px solid #FFF; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="info" id="ui-spd">SPEED: 0 kts</div>
        <div class="info" id="ui-alt">ALTITUDE: 0 m</div>
    </div>

    <div class="controls"><button id="btn-engine">TURN ON</button></div>
    <div class="thr-box"><b>THR</b><input type="range" id="input-thr" min="0" max="1" step="0.01" value="0"></div>
    <div id="joy-wrapper"><div id="joy-stick"></div></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

        function speakRadio(text) {
            if (window.speechSynthesis.speaking) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'pt-BR'; utterance.rate = 1.0; utterance.pitch = 0.6;
            window.speechSynthesis.speak(utterance);
        }

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xd1f3ff, 100, 50000); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000000);
        
        // --- LUZ E SOMBRA (Aumentado para não cortar) ---
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(200, 600, 200);
        sun.castShadow = true;
        sun.shadow.camera.left = -150; // Aumentado
        sun.shadow.camera.right = 150; // Aumentado
        sun.shadow.camera.top = 150;   // Aumentado
        sun.shadow.camera.bottom = -150;// Aumentado
        sun.shadow.camera.near = 1;
        sun.shadow.camera.far = 2500;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // --- CÉU ---
        const skyGeo = new THREE.SphereGeometry(2000000, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
            vertexShader: `varying vec3 vWorldPosition; void main() { vec4 worldPosition = modelMatrix * vec4( position, 1.0 ); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
            fragmentShader: `uniform vec3 topColor; uniform vec3 bottomColor; uniform float offset; uniform float exponent; varying vec3 vWorldPosition; void main() { float h = normalize( vWorldPosition ).y + offset; gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 ); }`,
            uniforms: { topColor: { value: new THREE.Color(0x00d4ff) }, bottomColor: { value: new THREE.Color(0xffffff) }, offset: { value: 0.05 }, exponent: { value: 0.6 } },
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // --- PLANETA ---
        const planetRadius = 637000;
        const planet = new THREE.Mesh(new THREE.SphereGeometry(planetRadius, 128, 128), new THREE.MeshStandardMaterial({ color: 0x337a33 }));
        planet.position.y = -planetRadius; planet.receiveShadow = true;
        scene.add(planet);

        // --- PISTA (Avião agora encara o Z negativo, que é a direção de voo) ---
        const runway = new THREE.Mesh(new THREE.PlaneGeometry(60, 3000), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        runway.rotation.x = -Math.PI / 2; runway.position.y = 0.05; runway.position.z = -1400; runway.receiveShadow = true;
        scene.add(runway);
        for(let i = 0; i > -2900; i -= 50) {
            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(3, 20), new THREE.MeshBasicMaterial({ color: 0xFFFFFF }));
            stripe.rotation.x = -Math.PI / 2; stripe.position.set(0, 0.07, i); scene.add(stripe);
        }

        // --- AVIÃO ---
        const planeGroup = new THREE.Group();
        const modelInner = new THREE.Group();
        planeGroup.add(modelInner);
        let speed = 0, engine = false, thr = 0, joy = { x: 0, y: 0 };
        new GLTFLoader().load('1.glb', (gltf) => {
            gltf.scene.rotation.y = Math.PI; gltf.scene.position.y = -0.55; 
            gltf.scene.traverse(n => { if(n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
            modelInner.add(gltf.scene);
        });
        scene.add(planeGroup);
        planeGroup.position.set(0, 0.6, 0); // Começa no início da pista

        // --- CÂMERA ORBITAL (Sensibilidade Ajustada e Sem Inversão) ---
        let camTheta = Math.PI, camPhi = 0.2, camDist = 35;
        let targetCamTheta = Math.PI, targetCamPhi = 0.2;
        let isMovingCam = false, lastX = 0, lastY = 0;

        const updateCam = (x, y) => {
            if (!isMovingCam) return;
            targetCamTheta -= (x - lastX) * 0.005; // Sensibilidade reduzida
            targetCamPhi = Math.max(0.05, Math.min(1.4, targetCamPhi + (y - lastY) * 0.005));
            lastX = x; lastY = y;
        };

        window.addEventListener('mousedown', e => { isMovingCam = true; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mousemove', e => updateCam(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => isMovingCam = false);
        window.addEventListener('touchstart', e => {
            if (e.target.tagName !== 'INPUT' && !document.getElementById('joy-wrapper').contains(e.target)) {
                isMovingCam = true; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
            }
        });
        window.addEventListener('touchmove', e => updateCam(e.touches[0].clientX, e.touches[0].clientY));
        window.addEventListener('touchend', () => isMovingCam = false);

        // --- JOYSTICK ---
        const stick = document.getElementById('joy-stick'), wrap = document.getElementById('joy-wrapper');
        const moveJoy = (e) => {
            const r = wrap.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            joy.x = ((cx - r.left - 70) / 70) * 0.6; 
            joy.y = ((cy - r.top - 70) / 70) * 0.6;  
            stick.style.transform = `translate(${joy.x * 60}px, ${joy.y * 60}px)`;
        };
        wrap.onpointermove = (e) => { if(e.buttons === 1 || e.touches) moveJoy(e); };
        wrap.onpointerup = () => { joy = { x: 0, y: 0 }; stick.style.transform = `translate(0,0)`; };

        document.getElementById('btn-engine').onclick = (e) => { 
            engine = !engine; e.target.innerText = engine ? "OFF" : "ON"; 
            if(engine) speakRadio("Torre ciente. Motor ligado. Decolagem autorizada pista zero um.");
        };
        document.getElementById('input-thr').oninput = (e) => thr = parseFloat(e.target.value);

        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const downVec = new THREE.Vector3(0, -1, 0);
        let lastSpeak = 0;

        function loop() {
            const dt = clock.getDelta();
            
            const rayOrigin = planeGroup.position.clone().add(new THREE.Vector3(0, 10, 0));
            raycaster.set(rayOrigin, downVec);
            const hits = raycaster.intersectObject(planet);
            let groundY = (hits.length > 0) ? hits[0].point.y : 0;

            // Lógica de pista ajustada para o novo posicionamento Z negativo
            const onRunway = Math.abs(planeGroup.position.x) < 30 && planeGroup.position.z <= 0 && planeGroup.position.z >= -3000;
            if(onRunway) groundY = 0.05;

            const currentAlt = planeGroup.position.y - groundY;
            const isGrounded = currentAlt <= 0.6;

            speed = THREE.MathUtils.lerp(speed, engine ? thr * ((currentAlt > 10) ? 316 : 160) : 0, dt * 0.6);

            if (engine && Date.now() - lastSpeak > 8000) {
                if (isGrounded && speed > 130) { speakRadio("V1. Rotate."); lastSpeak = Date.now(); }
            }

            if (isGrounded) {
                planeGroup.position.y = groundY + 0.55;
                planeGroup.rotation.y -= joy.x * dt * 0.6;
                if (speed > 100) planeGroup.rotation.x = THREE.MathUtils.lerp(planeGroup.rotation.x, joy.y * 0.2, dt * 1.5);
                if (speed > 140 && planeGroup.rotation.x > 0.02) planeGroup.position.y += speed * dt * 0.5;
            } else {
                planeGroup.rotation.x = THREE.MathUtils.lerp(planeGroup.rotation.x, joy.y * 0.8, dt * 1.2);
                planeGroup.rotation.z = THREE.MathUtils.lerp(planeGroup.rotation.z, -joy.x * 0.7, dt * 1.2);
                planeGroup.rotation.y -= planeGroup.rotation.z * dt * 0.5;
                planeGroup.position.y += ((speed / 160) * Math.max(0, 1 + planeGroup.rotation.x) - 1.05) * 60 * dt;
                if (planeGroup.position.y < groundY + 0.55) planeGroup.position.y = groundY + 0.55;
            }
            // Move para frente (Z negativo no Three.js)
            planeGroup.translateZ(speed * dt * 0.85);

            // CÂMERA ORBITAL
            camTheta = THREE.MathUtils.lerp(camTheta, targetCamTheta, 0.1);
            camPhi = THREE.MathUtils.lerp(camPhi, targetCamPhi, 0.1);
            camera.position.set(
                planeGroup.position.x + camDist * Math.sin(camTheta) * Math.cos(camPhi),
                planeGroup.position.y + camDist * Math.sin(camPhi),
                planeGroup.position.z + camDist * Math.cos(camTheta) * Math.cos(camPhi)
            );
            camera.lookAt(planeGroup.position);

            // SOMBRA SEGUE O AVIÃO SEM CORTAR
            sun.position.set(planeGroup.position.x + 100, planeGroup.position.y + 400, planeGroup.position.z + 100);
            sun.target = planeGroup;
            sky.position.copy(planeGroup.position);

            document.getElementById('ui-spd').innerText = `SPEED: ${Math.round(speed)} kts`;
            document.getElementById('ui-alt').innerText = `ALTITUDE: ${Math.max(0, Math.round(currentAlt))} m`;

            renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }
        loop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
                                       </html>

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Buraco Negro - Versão Mobile Distância</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px 0; color: #fff; background: rgba(0, 0, 0, 0.5);
            text-align: center; pointer-events: none; z-index: 10;
        }
        #info h1 { font-size: 1.2rem; margin: 0; }
        #info p { font-size: 0.8rem; margin: 5px 0 0 0; color: #aaa; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Buraco Negro (Mobile Lite)</h1>
        <p>Arraste para girar • Distância Aumentada</p>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIGURAÇÕES ---
        let scene, camera, renderer, material;
        let startX = 0, startY = 0;
        let lon = 90, lat = 0; // Começa olhando de frente
        let phi = 0, theta = 0;

        // --- SHADERS OTIMIZADOS (GLSL) ---
        
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                // Preenche a tela toda com um quadrado simples
                gl_Position = vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            // MUDANÇA CRÍTICA: mediump é mais leve e compatível com Moto e22
            precision mediump float;

            uniform float time;
            uniform vec2 resolution;
            uniform vec2 cameraRot; // Rotação vinda do JS

            // Constantes reduzidas para performance
            #define MAX_STEPS 30
            #define MAX_DIST 20.0
            #define SURF_DIST 0.01
            
            // Função de Rotação 3D
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // Gera estrelas simples (Muito mais leve que o noise anterior)
            float starField(vec3 p) {
                vec3 q = fract(p * 15.0) - 0.5;
                float d = length(q);
                // Cria pontinhos brancos se d for muito pequeno
                return smoothstep(0.1, 0.05, d) * 0.8; 
            }

            // O Buraco Negro e o Disco
            vec3 scene(vec3 ro, vec3 rd) {
                vec3 col = vec3(0.0);
                vec3 p = ro;
                float d = 0.0;
                float totalD = 0.0;
                
                // Variável para acumular o brilho do disco (Accretion Disk)
                float glow = 0.0;

                for(int i = 0; i < MAX_STEPS; i++) {
                    p = ro + rd * totalD;
                    float distToCenter = length(p);

                    // 1. Gravidade (Lente Gravitacional Simplificada)
                    // Puxa o raio em direção ao centro (0,0,0)
                    if(distToCenter > 0.5) {
                        vec3 gravitationalPull = -normalize(p) * (0.05 / (distToCenter * distToCenter));
                        rd += gravitationalPull;
                        rd = normalize(rd);
                    }

                    // 2. Disco de Acreção (Visual)
                    // Um anel chato no plano Y
                    float distToPlane = abs(p.y);
                    float distToHole = length(p.xz);
                    
                    if(distToHole > 1.2 && distToHole < 4.0) {
                        // Se o raio passar perto do plano Y
                        float brightness = 0.02 / (distToPlane + 0.05);
                        // Variação de cor baseada na distância
                        float temp = (4.0 - distToHole); 
                        glow += brightness * temp * 0.05; 
                    }

                    // Avança o raio
                    // Passos maiores longe, menores perto (Otimização)
                    float stepSize = max(0.1, distToCenter * 0.1); 
                    totalD += stepSize;
                    
                    // Horizonte de Eventos (Buraco Preto)
                    if(distToCenter < 1.0) {
                        return vec3(0.0); // Preto absoluto
                    }
                    if(totalD > MAX_DIST) break;
                }

                // Cor do Disco (Laranja/Amarelo)
                col += vec3(1.0, 0.6, 0.2) * glow;
                
                // Fundo Estrelado (Se o raio escapou)
                if(totalD > MAX_DIST || length(col) < 0.1) {
                    col += vec3(starField(rd)); // Estrelas
                    // Fundo azulado fraco
                    col += vec3(0.05, 0.05, 0.1) * (rd.y * 0.5 + 0.5); 
                }

                return col;
            }

            void main() {
                // Coordenadas da tela corrigidas
                vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;

                // Câmera Orbital
                // AJUSTE CRÍTICO AQUI: Aumentamos a distância de -8.0 para -16.0
                vec3 ro = vec3(0.0, 0.0, -16.0); // Origem do raio (Camera Position)
                
                // Aplica rotação do mouse/toque na origem
                ro.yz *= rot(cameraRot.y);
                ro.xz *= rot(cameraRot.x);

                vec3 rd = normalize(vec3(uv, 1.0)); // Direção do raio
                
                // Aplica rotação na direção também
                rd.yz *= rot(cameraRot.y);
                rd.xz *= rot(cameraRot.x);

                vec3 col = scene(ro, rd);

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function init() {
            const container = document.getElementById('container');

            // Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            
            // IMPORTANTE PARA MOTO E22: Limita a densidade de pixels para 1
            renderer.setPixelRatio(1); 
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Cena simples com um plano que cobre a tela (o shader faz o resto)
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            const geometry = new THREE.PlaneGeometry(2, 2);
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    cameraRot: { value: new THREE.Vector2(0, 0) }
                }
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Eventos
            window.addEventListener('resize', onWindowResize, false);
            addTouchControls();

            animate();
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        }

        // Controles de Toque/Mouse manuais (Sem OrbitControls para ficar leve)
        function addTouchControls() {
            let isDragging = false;
            
            // Mouse
            document.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX; startY = e.clientY; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', (e) => {
                if(!isDragging) return;
                let dx = e.clientX - startX;
                let dy = e.clientY - startY;
                lon -= dx * 0.01; lat += dy * 0.01;
                lat = Math.max(-1.5, Math.min(1.5, lat)); // Trava vertical
                startX = e.clientX; startY = e.clientY;
            });

            // Toque (Mobile)
            document.addEventListener('touchstart', (e) => { 
                isDragging = true; 
                startX = e.touches[0].clientX; 
                startY = e.touches[0].clientY; 
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if(!isDragging) return;
                e.preventDefault(); // Evita rolar a página
                let dx = e.touches[0].clientX - startX;
                let dy = e.touches[0].clientY - startY;
                lon -= dx * 0.02; lat += dy * 0.02; // Sensibilidade um pouco maior no mobile
                lat = Math.max(-1.5, Math.min(1.5, lat));
                startX = e.touches[0].clientX; startY = e.touches[0].clientY;
            }, { passive: false });
            
            document.addEventListener('touchend', () => { isDragging = false; });
        }

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.time.value += 0.05; // Velocidade da animação
            material.uniforms.cameraRot.value.set(lon, lat);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

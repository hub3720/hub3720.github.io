<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Buraco Negro Leve v3</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 10px 0; color: rgba(255, 255, 255, 0.8); 
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            text-align: center; pointer-events: none; z-index: 10;
        }
        #info h1 { font-size: 1rem; margin: 0; text-transform: uppercase; letter-spacing: 1px; }
        #info p { font-size: 0.75rem; margin: 2px 0; color: #fbac13; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Gargantua v3</h1>
        <p>1 Dedo: Girar • 2 Dedos: Zoom (Pinça)</p>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- VARIÁVEIS GLOBAIS ---
        let scene, camera, renderer, material;
        
        // Câmera (Começa mais longe como pediu)
        let camDist = 14.0; 
        
        // Rotação
        let lon = 0.0;
        let lat = -0.2; 

        // Controle de Toque
        let lastX = 0, lastY = 0;
        let lastPinchDist = 0;
        let isDragging = false;
        let isZooming = false;

        // --- SHADER GLSL (Otimizado para não dar tela preta) ---
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            precision mediump float; // MANTIDO: Essencial para seu celular

            uniform float time;
            uniform vec2 resolution;
            uniform vec2 cameraRot; // Rotação X, Y
            uniform float camDist;  // Zoom

            // Reduzi um pouco os passos para garantir FPS
            #define MAX_STEPS 30
            #define MAX_DIST 40.0
            
            // Função de Rotação Leve
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            vec3 scene(vec3 ro, vec3 rd) {
                vec3 col = vec3(0.0);
                vec3 p = ro;
                float totalD = 0.0;
                float glow = 0.0;

                for(int i = 0; i < MAX_STEPS; i++) {
                    p = ro + rd * totalD;
                    float distToCenter = length(p);

                    // 1. Gravidade (Lente)
                    if(distToCenter > 0.8) {
                        // Matemática simplificada da gravidade para não travar
                        float force = 0.1 / (distToCenter * distToCenter + 0.1); 
                        rd -= p * force * 0.2; 
                        rd = normalize(rd);
                    }

                    // 2. Disco de Acreção (Visual Realista Leve)
                    // Checa se está perto do plano do disco (Y=0)
                    float distToPlane = abs(p.y);
                    
                    if(distToPlane < 0.5) {
                        float r = length(p.xz); // Distância horizontal
                        // O disco existe entre raio 1.5 e 5.0
                        if(r > 1.5 && r < 5.0) {
                            // Brilho aumenta perto do buraco
                            float intensity = 0.1 / (distToPlane + 0.05);
                            
                            // Gradiente de cor: Laranja no centro, Vermelho na borda
                            float temp = (5.0 - r) / 3.5; // 1.0 perto, 0.0 longe
                            glow += intensity * temp * temp * 0.15; 
                        }
                    }

                    // Passo do raio (Raymarching)
                    float step = max(0.15, distToCenter * 0.15);
                    totalD += step;
                    
                    // Horizonte de Eventos
                    if(distToCenter < 1.0) return vec3(0.0); // Buraco Negro
                    if(totalD > MAX_DIST) break;
                }

                // Cor Final do Disco (Laranja Interstellar)
                vec3 diskColor = vec3(1.2, 0.7, 0.2) * glow * 2.0;
                
                // Adiciona um pouco de vermelho nas bordas externas do brilho
                diskColor += vec3(0.5, 0.1, 0.1) * glow;

                col += diskColor;
                
                // Fundo Estrelado (Se não bateu no buraco)
                if(totalD > MAX_DIST) {
                    // Estrelas falsas usando matemática simples de sobra
                    float stars = step(0.98, fract(sin(dot(rd.xy, vec3(12.9, 78.2, 45.1))) * 43758.5));
                    col += vec3(stars);
                }

                return col;
            }

            void main() {
                // Arruma a proporção da tela
                vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;

                // Câmera: Usa a variável camDist para o Zoom
                vec3 ro = vec3(0.0, 0.0, -camDist); 
                vec3 rd = normalize(vec3(uv, 1.2)); // 1.2 define o campo de visão (FOV)

                // Aplica rotação (Controlada pelo dedo)
                ro.yz *= rot(cameraRot.y);
                ro.xz *= rot(cameraRot.x);
                rd.yz *= rot(cameraRot.y);
                rd.xz *= rot(cameraRot.x);

                // Renderiza
                vec3 col = scene(ro, rd);

                // Tone Mapping (Deixa a cor mais bonita e menos estourada)
                col = col / (1.0 + col);

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // --- LÓGICA DO JAVASCRIPT ---
        function init() {
            const container = document.getElementById('container');
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setPixelRatio(1); // MANTIDO: Leveza
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            const geometry = new THREE.PlaneGeometry(2, 2);
            
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    cameraRot: { value: new THREE.Vector2(lon, lat) },
                    camDist: { value: camDist } // Passa o zoom para o shader
                }
            });

            scene.add(new THREE.Mesh(geometry, material));
            
            // Câmera dummy (o shader faz o trabalho real)
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            });

            setupTouchControls();
            animate();
        }

        function setupTouchControls() {
            const el = document.getElementById('container');

            // Função helper para distância entre dois dedos
            const getDist = (e) => {
                return Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            };

            el.addEventListener('touchstart', e => {
                if(e.touches.length === 1) {
                    isDragging = true; isZooming = false;
                    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
                } else if(e.touches.length === 2) {
                    isZooming = true; isDragging = false;
                    lastPinchDist = getDist(e);
                }
            }, { passive: false });

            el.addEventListener('touchmove', e => {
                e.preventDefault(); 
                
                // ROTAÇÃO (1 Dedo)
                if(isDragging && e.touches.length === 1) {
                    let dx = e.touches[0].clientX - lastX;
                    let dy = e.touches[0].clientY - lastY;
                    lon -= dx * 0.01; 
                    lat += dy * 0.01;
                    lat = Math.max(-1.5, Math.min(1.5, lat)); // Trava vertical
                    
                    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
                } 
                
                // ZOOM (2 Dedos - Pinça)
                else if(isZooming && e.touches.length === 2) {
                    let currentDist = getDist(e);
                    let delta = lastPinchDist - currentDist;
                    
                    camDist += delta * 0.05; // Velocidade do zoom
                    camDist = Math.max(5.0, Math.min(40.0, camDist)); // Limites min/max
                    
                    lastPinchDist = currentDist;
                }
            }, { passive: false });

            el.addEventListener('touchend', () => { isDragging = false; isZooming = false; });
            
            // Suporte mouse PC
            el.addEventListener('mousedown', e => { isDragging=true; lastX=e.clientX; lastY=e.clientY; });
            window.addEventListener('mouseup', () => isDragging=false);
            window.addEventListener('mousemove', e => {
                if(isDragging) {
                    lon -= (e.clientX - lastX)*0.005; 
                    lat += (e.clientY - lastY)*0.005;
                    lat = Math.max(-1.5, Math.min(1.5, lat));
                    lastX = e.clientX; lastY = e.clientY;
                }
            });
            el.addEventListener('wheel', e => {
                camDist += e.deltaY * 0.01;
                camDist = Math.max(5.0, Math.min(40.0, camDist));
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.time.value += 0.01;
            material.uniforms.cameraRot.value.set(lon, lat);
            material.uniforms.camDist.value = camDist;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
    </html>
